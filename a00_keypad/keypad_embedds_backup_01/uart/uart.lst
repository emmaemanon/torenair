   1               		.file	"uart.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_18
  12               	__vector_18:
  13               	.LFB1:
  14               		.file 1 "uart/uart.c"
   1:uart/uart.c   **** /*************************************************************************
   2:uart/uart.c   **** Title:    Interrupt UART library with receive/transmit circular buffers
   3:uart/uart.c   **** Author:   Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   4:uart/uart.c   **** File:     $Id: uart.c,v 1.6.2.2 2009/11/29 08:56:12 Peter Exp $
   5:uart/uart.c   **** Software: AVR-GCC 4.1, AVR Libc 1.4.6 or higher
   6:uart/uart.c   **** Hardware: any AVR with built-in UART, 
   7:uart/uart.c   **** License:  GNU General Public License 
   8:uart/uart.c   ****           
   9:uart/uart.c   **** DESCRIPTION:
  10:uart/uart.c   ****     An interrupt is generated when the UART has finished transmitting or
  11:uart/uart.c   ****     receiving a byte. The interrupt handling routines use circular buffers
  12:uart/uart.c   ****     for buffering received and transmitted data.
  13:uart/uart.c   ****     
  14:uart/uart.c   ****     The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define
  15:uart/uart.c   ****     the buffer size in bytes. Note that these variables must be a 
  16:uart/uart.c   ****     power of 2.
  17:uart/uart.c   ****     
  18:uart/uart.c   **** USAGE:
  19:uart/uart.c   ****     Refere to the header file uart.h for a description of the routines. 
  20:uart/uart.c   ****     See also example test_uart.c.
  21:uart/uart.c   **** 
  22:uart/uart.c   **** NOTES:
  23:uart/uart.c   ****     Based on Atmel Application Note AVR306
  24:uart/uart.c   ****                     
  25:uart/uart.c   **** LICENSE:
  26:uart/uart.c   ****     Copyright (C) 2006 Peter Fleury
  27:uart/uart.c   **** 
  28:uart/uart.c   ****     This program is free software; you can redistribute it and/or modify
  29:uart/uart.c   ****     it under the terms of the GNU General Public License as published by
  30:uart/uart.c   ****     the Free Software Foundation; either version 2 of the License, or
  31:uart/uart.c   ****     any later version.
  32:uart/uart.c   **** 
  33:uart/uart.c   ****     This program is distributed in the hope that it will be useful,
  34:uart/uart.c   ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  35:uart/uart.c   ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  36:uart/uart.c   ****     GNU General Public License for more details.
  37:uart/uart.c   ****                         
  38:uart/uart.c   **** *************************************************************************/
  39:uart/uart.c   **** #include <avr/io.h>
  40:uart/uart.c   **** #include <avr/interrupt.h>
  41:uart/uart.c   **** #include <avr/pgmspace.h>
  42:uart/uart.c   **** #include "uart.h"
  43:uart/uart.c   **** 
  44:uart/uart.c   **** 
  45:uart/uart.c   **** /*
  46:uart/uart.c   ****  *  constants and macros
  47:uart/uart.c   ****  */
  48:uart/uart.c   **** 
  49:uart/uart.c   **** /* size of RX/TX buffers */
  50:uart/uart.c   **** #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)
  51:uart/uart.c   **** #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)
  52:uart/uart.c   **** 
  53:uart/uart.c   **** #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )
  54:uart/uart.c   **** #error RX buffer size is not a power of 2
  55:uart/uart.c   **** #endif
  56:uart/uart.c   **** #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )
  57:uart/uart.c   **** #error TX buffer size is not a power of 2
  58:uart/uart.c   **** #endif
  59:uart/uart.c   **** 
  60:uart/uart.c   **** #if defined(__AVR_AT90S2313__) \
  61:uart/uart.c   ****  || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S4434__) \
  62:uart/uart.c   ****  || defined(__AVR_AT90S8515__) || defined(__AVR_AT90S8535__) \
  63:uart/uart.c   ****  || defined(__AVR_ATmega103__)
  64:uart/uart.c   ****  /* old AVR classic or ATmega103 with one UART */
  65:uart/uart.c   ****  #define AT90_UART
  66:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
  67:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
  68:uart/uart.c   ****  #define UART0_STATUS   USR
  69:uart/uart.c   ****  #define UART0_CONTROL  UCR
  70:uart/uart.c   ****  #define UART0_DATA     UDR  
  71:uart/uart.c   ****  #define UART0_UDRIE    UDRIE
  72:uart/uart.c   **** #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)
  73:uart/uart.c   ****  /* old AVR classic with one UART */
  74:uart/uart.c   ****  #define AT90_UART
  75:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
  76:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
  77:uart/uart.c   ****  #define UART0_STATUS   UCSRA
  78:uart/uart.c   ****  #define UART0_CONTROL  UCSRB
  79:uart/uart.c   ****  #define UART0_DATA     UDR 
  80:uart/uart.c   ****  #define UART0_UDRIE    UDRIE
  81:uart/uart.c   **** #elif  defined(__AVR_ATmega8__)  || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
  82:uart/uart.c   ****   || defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__) \
  83:uart/uart.c   ****   || defined(__AVR_ATmega323__)
  84:uart/uart.c   ****   /* ATmega with one USART */
  85:uart/uart.c   ****  #define ATMEGA_USART
  86:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
  87:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
  88:uart/uart.c   ****  #define UART0_STATUS   UCSRA
  89:uart/uart.c   ****  #define UART0_CONTROL  UCSRB
  90:uart/uart.c   ****  #define UART0_DATA     UDR
  91:uart/uart.c   ****  #define UART0_UDRIE    UDRIE
  92:uart/uart.c   **** #elif defined(__AVR_ATmega163__) 
  93:uart/uart.c   ****   /* ATmega163 with one UART */
  94:uart/uart.c   ****  #define ATMEGA_UART
  95:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
  96:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
  97:uart/uart.c   ****  #define UART0_STATUS   UCSRA
  98:uart/uart.c   ****  #define UART0_CONTROL  UCSRB
  99:uart/uart.c   ****  #define UART0_DATA     UDR
 100:uart/uart.c   ****  #define UART0_UDRIE    UDRIE
 101:uart/uart.c   **** #elif defined(__AVR_ATmega162__) 
 102:uart/uart.c   ****  /* ATmega with two USART */
 103:uart/uart.c   ****  #define ATMEGA_USART0
 104:uart/uart.c   ****  #define ATMEGA_USART1
 105:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART0_RECV
 106:uart/uart.c   ****  #define UART1_RECEIVE_INTERRUPT   SIG_USART1_RECV
 107:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART0_DATA
 108:uart/uart.c   ****  #define UART1_TRANSMIT_INTERRUPT  SIG_USART1_DATA
 109:uart/uart.c   ****  #define UART0_STATUS   UCSR0A
 110:uart/uart.c   ****  #define UART0_CONTROL  UCSR0B
 111:uart/uart.c   ****  #define UART0_DATA     UDR0
 112:uart/uart.c   ****  #define UART0_UDRIE    UDRIE0
 113:uart/uart.c   ****  #define UART1_STATUS   UCSR1A
 114:uart/uart.c   ****  #define UART1_CONTROL  UCSR1B
 115:uart/uart.c   ****  #define UART1_DATA     UDR1
 116:uart/uart.c   ****  #define UART1_UDRIE    UDRIE1
 117:uart/uart.c   **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) 
 118:uart/uart.c   ****  /* ATmega with two USART */
 119:uart/uart.c   ****  #define ATMEGA_USART0
 120:uart/uart.c   ****  #define ATMEGA_USART1
 121:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART0_RECV
 122:uart/uart.c   ****  #define UART1_RECEIVE_INTERRUPT   SIG_UART1_RECV
 123:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART0_DATA
 124:uart/uart.c   ****  #define UART1_TRANSMIT_INTERRUPT  SIG_UART1_DATA
 125:uart/uart.c   ****  #define UART0_STATUS   UCSR0A
 126:uart/uart.c   ****  #define UART0_CONTROL  UCSR0B
 127:uart/uart.c   ****  #define UART0_DATA     UDR0
 128:uart/uart.c   ****  #define UART0_UDRIE    UDRIE0
 129:uart/uart.c   ****  #define UART1_STATUS   UCSR1A
 130:uart/uart.c   ****  #define UART1_CONTROL  UCSR1B
 131:uart/uart.c   ****  #define UART1_DATA     UDR1
 132:uart/uart.c   ****  #define UART1_UDRIE    UDRIE1
 133:uart/uart.c   **** #elif defined(__AVR_ATmega161__)
 134:uart/uart.c   ****  /* ATmega with UART */
 135:uart/uart.c   ****  #error "AVR ATmega161 currently not supported by this libaray !"
 136:uart/uart.c   **** #elif defined(__AVR_ATmega169__) 
 137:uart/uart.c   ****  /* ATmega with one USART */
 138:uart/uart.c   ****  #define ATMEGA_USART
 139:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART_RECV
 140:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART_DATA
 141:uart/uart.c   ****  #define UART0_STATUS   UCSRA
 142:uart/uart.c   ****  #define UART0_CONTROL  UCSRB
 143:uart/uart.c   ****  #define UART0_DATA     UDR
 144:uart/uart.c   ****  #define UART0_UDRIE    UDRIE
 145:uart/uart.c   **** #elif defined(__AVR_ATmega48__) ||defined(__AVR_ATmega88__) || defined(__AVR_ATmega168__)
 146:uart/uart.c   ****  /* ATmega with one USART */
 147:uart/uart.c   ****  #define ATMEGA_USART0
 148:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART_RECV
 149:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART_DATA
 150:uart/uart.c   ****  #define UART0_STATUS   UCSR0A
 151:uart/uart.c   ****  #define UART0_CONTROL  UCSR0B
 152:uart/uart.c   ****  #define UART0_DATA     UDR0
 153:uart/uart.c   ****  #define UART0_UDRIE    UDRIE0
 154:uart/uart.c   **** #elif defined(__AVR_ATmega168P__) || defined(__AVR_ATmega328P__)
 155:uart/uart.c   ****  /* ATmega with one USART */
 156:uart/uart.c   ****  #define ATMEGA_USART0
 157:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 158:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 159:uart/uart.c   ****  #define UART0_STATUS   UCSR0A
 160:uart/uart.c   ****  #define UART0_CONTROL  UCSR0B
 161:uart/uart.c   ****  #define UART0_DATA     UDR0
 162:uart/uart.c   ****  #define UART0_UDRIE    UDRIE0
 163:uart/uart.c   **** #elif defined(__AVR_ATtiny2313__)
 164:uart/uart.c   ****  #define ATMEGA_USART
 165:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART0_RX 
 166:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART0_UDRE
 167:uart/uart.c   ****  #define UART0_STATUS   UCSRA
 168:uart/uart.c   ****  #define UART0_CONTROL  UCSRB
 169:uart/uart.c   ****  #define UART0_DATA     UDR
 170:uart/uart.c   ****  #define UART0_UDRIE    UDRIE
 171:uart/uart.c   **** #elif defined(__AVR_ATmega329__) ||defined(__AVR_ATmega3290__) ||\
 172:uart/uart.c   ****       defined(__AVR_ATmega649__) ||defined(__AVR_ATmega6490__) ||\
 173:uart/uart.c   ****       defined(__AVR_ATmega325__) ||defined(__AVR_ATmega3250__) ||\
 174:uart/uart.c   ****       defined(__AVR_ATmega645__) ||defined(__AVR_ATmega6450__)
 175:uart/uart.c   ****   /* ATmega with one USART */
 176:uart/uart.c   ****   #define ATMEGA_USART0
 177:uart/uart.c   ****   #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
 178:uart/uart.c   ****   #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
 179:uart/uart.c   ****   #define UART0_STATUS   UCSR0A
 180:uart/uart.c   ****   #define UART0_CONTROL  UCSR0B
 181:uart/uart.c   ****   #define UART0_DATA     UDR0
 182:uart/uart.c   ****   #define UART0_UDRIE    UDRIE0
 183:uart/uart.c   **** #elif defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1280__)  ||
 184:uart/uart.c   **** /* ATmega with two USART */
 185:uart/uart.c   ****   #define ATMEGA_USART0
 186:uart/uart.c   ****   #define ATMEGA_USART1
 187:uart/uart.c   ****   #define UART0_RECEIVE_INTERRUPT   SIG_USART0_RECV
 188:uart/uart.c   ****   #define UART1_RECEIVE_INTERRUPT   SIG_USART1_RECV
 189:uart/uart.c   ****   #define UART0_TRANSMIT_INTERRUPT  SIG_USART0_DATA
 190:uart/uart.c   ****   #define UART1_TRANSMIT_INTERRUPT  SIG_USART1_DATA
 191:uart/uart.c   ****   #define UART0_STATUS   UCSR0A
 192:uart/uart.c   ****   #define UART0_CONTROL  UCSR0B
 193:uart/uart.c   ****   #define UART0_DATA     UDR0
 194:uart/uart.c   ****   #define UART0_UDRIE    UDRIE0
 195:uart/uart.c   ****   #define UART1_STATUS   UCSR1A
 196:uart/uart.c   ****   #define UART1_CONTROL  UCSR1B
 197:uart/uart.c   ****   #define UART1_DATA     UDR1
 198:uart/uart.c   ****   #define UART1_UDRIE    UDRIE1  
 199:uart/uart.c   **** #elif defined(__AVR_ATmega644__)
 200:uart/uart.c   ****  /* ATmega with one USART */
 201:uart/uart.c   ****  #define ATMEGA_USART0
 202:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART_RECV
 203:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART_DATA
 204:uart/uart.c   ****  #define UART0_STATUS   UCSR0A
 205:uart/uart.c   ****  #define UART0_CONTROL  UCSR0B
 206:uart/uart.c   ****  #define UART0_DATA     UDR0
 207:uart/uart.c   ****  #define UART0_UDRIE    UDRIE0
 208:uart/uart.c   **** #elif defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__)
 209:uart/uart.c   ****  /* ATmega with two USART */
 210:uart/uart.c   ****  #define ATMEGA_USART0
 211:uart/uart.c   ****  #define ATMEGA_USART1
 212:uart/uart.c   ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART_RECV
 213:uart/uart.c   ****  #define UART1_RECEIVE_INTERRUPT   SIG_USART1_RECV
 214:uart/uart.c   ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART_DATA
 215:uart/uart.c   ****  #define UART1_TRANSMIT_INTERRUPT  SIG_USART1_DATA
 216:uart/uart.c   ****  #define UART0_STATUS   UCSR0A
 217:uart/uart.c   ****  #define UART0_CONTROL  UCSR0B
 218:uart/uart.c   ****  #define UART0_DATA     UDR0
 219:uart/uart.c   ****  #define UART0_UDRIE    UDRIE0
 220:uart/uart.c   ****  #define UART1_STATUS   UCSR1A
 221:uart/uart.c   ****  #define UART1_CONTROL  UCSR1B
 222:uart/uart.c   ****  #define UART1_DATA     UDR1
 223:uart/uart.c   ****  #define UART1_UDRIE    UDRIE1
 224:uart/uart.c   **** #else
 225:uart/uart.c   ****  #error "no UART definition for MCU available"
 226:uart/uart.c   **** #endif
 227:uart/uart.c   **** 
 228:uart/uart.c   **** 
 229:uart/uart.c   **** /*
 230:uart/uart.c   ****  *  module global variables
 231:uart/uart.c   ****  */
 232:uart/uart.c   **** static volatile unsigned char UART_TxBuf[UART_TX_BUFFER_SIZE];
 233:uart/uart.c   **** static volatile unsigned char UART_RxBuf[UART_RX_BUFFER_SIZE];
 234:uart/uart.c   **** static volatile unsigned char UART_TxHead;
 235:uart/uart.c   **** static volatile unsigned char UART_TxTail;
 236:uart/uart.c   **** static volatile unsigned char UART_RxHead;
 237:uart/uart.c   **** static volatile unsigned char UART_RxTail;
 238:uart/uart.c   **** static volatile unsigned char UART_LastRxError;
 239:uart/uart.c   **** 
 240:uart/uart.c   **** #if defined( ATMEGA_USART1 )
 241:uart/uart.c   **** static volatile unsigned char UART1_TxBuf[UART_TX_BUFFER_SIZE];
 242:uart/uart.c   **** static volatile unsigned char UART1_RxBuf[UART_RX_BUFFER_SIZE];
 243:uart/uart.c   **** static volatile unsigned char UART1_TxHead;
 244:uart/uart.c   **** static volatile unsigned char UART1_TxTail;
 245:uart/uart.c   **** static volatile unsigned char UART1_RxHead;
 246:uart/uart.c   **** static volatile unsigned char UART1_RxTail;
 247:uart/uart.c   **** static volatile unsigned char UART1_LastRxError;
 248:uart/uart.c   **** #endif
 249:uart/uart.c   **** 
 250:uart/uart.c   **** 
 251:uart/uart.c   **** 
 252:uart/uart.c   **** SIGNAL(UART0_RECEIVE_INTERRUPT)
 253:uart/uart.c   **** /*************************************************************************
 254:uart/uart.c   **** Function: UART Receive Complete interrupt
 255:uart/uart.c   **** Purpose:  called when the UART has received a character
 256:uart/uart.c   **** **************************************************************************/
 257:uart/uart.c   **** {
  15               		.loc 1 257 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28 000a 2F93      		push r18
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 18, -4
  32 000c 8F93      		push r24
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 24, -5
  36 000e 9F93      		push r25
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 25, -6
  40 0010 EF93      		push r30
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 30, -7
  44 0012 FF93      		push r31
  45               	.LCFI6:
  46               		.cfi_def_cfa_offset 9
  47               		.cfi_offset 31, -8
  48               	/* prologue: Signal */
  49               	/* frame size = 0 */
  50               	/* stack size = 8 */
  51               	.L__stack_usage = 8
 258:uart/uart.c   ****     unsigned char tmphead;
 259:uart/uart.c   ****     unsigned char data;
 260:uart/uart.c   ****     unsigned char usr;
 261:uart/uart.c   ****     unsigned char lastRxError;
 262:uart/uart.c   ****  
 263:uart/uart.c   ****  
 264:uart/uart.c   ****     /* read UART status register and UART data register */ 
 265:uart/uart.c   ****     usr  = UART0_STATUS;
  52               		.loc 1 265 0
  53 0014 8091 C000 		lds r24,192
  54               	.LVL0:
 266:uart/uart.c   ****     data = UART0_DATA;
  55               		.loc 1 266 0
  56 0018 9091 C600 		lds r25,198
  57               	.LVL1:
 267:uart/uart.c   ****     
 268:uart/uart.c   ****     /* */
 269:uart/uart.c   **** #if defined( AT90_UART )
 270:uart/uart.c   ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 271:uart/uart.c   **** #elif defined( ATMEGA_USART )
 272:uart/uart.c   ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 273:uart/uart.c   **** #elif defined( ATMEGA_USART0 )
 274:uart/uart.c   ****     lastRxError = (usr & (_BV(FE0)|_BV(DOR0)) );
  58               		.loc 1 274 0
  59 001c 8871      		andi r24,lo8(24)
  60               	.LVL2:
 275:uart/uart.c   **** #elif defined ( ATMEGA_UART )
 276:uart/uart.c   ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 277:uart/uart.c   **** #endif
 278:uart/uart.c   ****         
 279:uart/uart.c   ****     /* calculate buffer index */ 
 280:uart/uart.c   ****     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
  61               		.loc 1 280 0
  62 001e E091 0000 		lds r30,UART_RxHead
  63 0022 EF5F      		subi r30,lo8(-(1))
  64 0024 EF71      		andi r30,lo8(31)
  65               	.LVL3:
 281:uart/uart.c   ****     
 282:uart/uart.c   ****     if ( tmphead == UART_RxTail ) {
  66               		.loc 1 282 0
  67 0026 2091 0000 		lds r18,UART_RxTail
  68 002a E217      		cp r30,r18
  69 002c 01F0      		breq .L3
 283:uart/uart.c   ****         /* error: receive buffer overflow */
 284:uart/uart.c   ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 285:uart/uart.c   ****     }else{
 286:uart/uart.c   ****         /* store new index */
 287:uart/uart.c   ****         UART_RxHead = tmphead;
  70               		.loc 1 287 0
  71 002e E093 0000 		sts UART_RxHead,r30
 288:uart/uart.c   ****         /* store received data in buffer */
 289:uart/uart.c   ****         UART_RxBuf[tmphead] = data;
  72               		.loc 1 289 0
  73 0032 F0E0      		ldi r31,0
  74 0034 E050      		subi r30,lo8(-(UART_RxBuf))
  75 0036 F040      		sbci r31,hi8(-(UART_RxBuf))
  76               	.LVL4:
  77 0038 9083      		st Z,r25
  78               	.LVL5:
  79 003a 00C0      		rjmp .L2
  80               	.LVL6:
  81               	.L3:
 284:uart/uart.c   ****     }else{
  82               		.loc 1 284 0
  83 003c 82E0      		ldi r24,lo8(2)
  84               	.LVL7:
  85               	.L2:
 290:uart/uart.c   ****     }
 291:uart/uart.c   ****     UART_LastRxError = lastRxError;   
  86               		.loc 1 291 0
  87 003e 8093 0000 		sts UART_LastRxError,r24
  88               	/* epilogue start */
 292:uart/uart.c   **** }
  89               		.loc 1 292 0
  90 0042 FF91      		pop r31
  91 0044 EF91      		pop r30
  92 0046 9F91      		pop r25
  93               	.LVL8:
  94 0048 8F91      		pop r24
  95               	.LVL9:
  96 004a 2F91      		pop r18
  97 004c 0F90      		pop r0
  98 004e 0FBE      		out __SREG__,r0
  99               	.LVL10:
 100 0050 0F90      		pop r0
 101 0052 1F90      		pop r1
 102 0054 1895      		reti
 103               		.cfi_endproc
 104               	.LFE1:
 106               	.global	__vector_19
 108               	__vector_19:
 109               	.LFB2:
 293:uart/uart.c   **** 
 294:uart/uart.c   **** 
 295:uart/uart.c   **** SIGNAL(UART0_TRANSMIT_INTERRUPT)
 296:uart/uart.c   **** /*************************************************************************
 297:uart/uart.c   **** Function: UART Data Register Empty interrupt
 298:uart/uart.c   **** Purpose:  called when the UART is ready to transmit the next byte
 299:uart/uart.c   **** **************************************************************************/
 300:uart/uart.c   **** {
 110               		.loc 1 300 0
 111               		.cfi_startproc
 112 0056 1F92      		push r1
 113               	.LCFI7:
 114               		.cfi_def_cfa_offset 3
 115               		.cfi_offset 1, -2
 116 0058 0F92      		push r0
 117               	.LCFI8:
 118               		.cfi_def_cfa_offset 4
 119               		.cfi_offset 0, -3
 120 005a 0FB6      		in r0,__SREG__
 121 005c 0F92      		push r0
 122 005e 1124      		clr __zero_reg__
 123 0060 8F93      		push r24
 124               	.LCFI9:
 125               		.cfi_def_cfa_offset 5
 126               		.cfi_offset 24, -4
 127 0062 9F93      		push r25
 128               	.LCFI10:
 129               		.cfi_def_cfa_offset 6
 130               		.cfi_offset 25, -5
 131 0064 EF93      		push r30
 132               	.LCFI11:
 133               		.cfi_def_cfa_offset 7
 134               		.cfi_offset 30, -6
 135 0066 FF93      		push r31
 136               	.LCFI12:
 137               		.cfi_def_cfa_offset 8
 138               		.cfi_offset 31, -7
 139               	/* prologue: Signal */
 140               	/* frame size = 0 */
 141               	/* stack size = 7 */
 142               	.L__stack_usage = 7
 301:uart/uart.c   ****     unsigned char tmptail;
 302:uart/uart.c   **** 
 303:uart/uart.c   ****     
 304:uart/uart.c   ****     if ( UART_TxHead != UART_TxTail) {
 143               		.loc 1 304 0
 144 0068 9091 0000 		lds r25,UART_TxHead
 145 006c 8091 0000 		lds r24,UART_TxTail
 146 0070 9817      		cp r25,r24
 147 0072 01F0      		breq .L6
 305:uart/uart.c   ****         /* calculate and store new buffer index */
 306:uart/uart.c   ****         tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 148               		.loc 1 306 0
 149 0074 E091 0000 		lds r30,UART_TxTail
 150 0078 EF5F      		subi r30,lo8(-(1))
 151 007a EF71      		andi r30,lo8(31)
 152               	.LVL11:
 307:uart/uart.c   ****         UART_TxTail = tmptail;
 153               		.loc 1 307 0
 154 007c E093 0000 		sts UART_TxTail,r30
 308:uart/uart.c   ****         /* get one byte from buffer and write it to UART */
 309:uart/uart.c   ****         UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 155               		.loc 1 309 0
 156 0080 F0E0      		ldi r31,0
 157 0082 E050      		subi r30,lo8(-(UART_TxBuf))
 158 0084 F040      		sbci r31,hi8(-(UART_TxBuf))
 159               	.LVL12:
 160 0086 8081      		ld r24,Z
 161 0088 8093 C600 		sts 198,r24
 162               	.LVL13:
 163 008c 00C0      		rjmp .L5
 164               	.L6:
 310:uart/uart.c   ****     }else{
 311:uart/uart.c   ****         /* tx buffer empty, disable UDRE interrupt */
 312:uart/uart.c   ****         UART0_CONTROL &= ~_BV(UART0_UDRIE);
 165               		.loc 1 312 0
 166 008e 8091 C100 		lds r24,193
 167 0092 8F7D      		andi r24,lo8(-33)
 168 0094 8093 C100 		sts 193,r24
 169               	.L5:
 170               	/* epilogue start */
 313:uart/uart.c   ****     }
 314:uart/uart.c   **** }
 171               		.loc 1 314 0
 172 0098 FF91      		pop r31
 173 009a EF91      		pop r30
 174 009c 9F91      		pop r25
 175 009e 8F91      		pop r24
 176 00a0 0F90      		pop r0
 177 00a2 0FBE      		out __SREG__,r0
 178 00a4 0F90      		pop r0
 179 00a6 1F90      		pop r1
 180 00a8 1895      		reti
 181               		.cfi_endproc
 182               	.LFE2:
 184               	.global	uart_init
 186               	uart_init:
 187               	.LFB3:
 315:uart/uart.c   **** 
 316:uart/uart.c   **** 
 317:uart/uart.c   **** /*************************************************************************
 318:uart/uart.c   **** Function: uart_init()
 319:uart/uart.c   **** Purpose:  initialize UART and set baudrate
 320:uart/uart.c   **** Input:    baudrate using macro UART_BAUD_SELECT()
 321:uart/uart.c   **** Returns:  none
 322:uart/uart.c   **** **************************************************************************/
 323:uart/uart.c   **** void uart_init(unsigned int baudrate)
 324:uart/uart.c   **** {
 188               		.loc 1 324 0
 189               		.cfi_startproc
 190               	.LVL14:
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 325:uart/uart.c   ****     UART_TxHead = 0;
 195               		.loc 1 325 0
 196 00aa 1092 0000 		sts UART_TxHead,__zero_reg__
 326:uart/uart.c   ****     UART_TxTail = 0;
 197               		.loc 1 326 0
 198 00ae 1092 0000 		sts UART_TxTail,__zero_reg__
 327:uart/uart.c   ****     UART_RxHead = 0;
 199               		.loc 1 327 0
 200 00b2 1092 0000 		sts UART_RxHead,__zero_reg__
 328:uart/uart.c   ****     UART_RxTail = 0;
 201               		.loc 1 328 0
 202 00b6 1092 0000 		sts UART_RxTail,__zero_reg__
 329:uart/uart.c   ****     
 330:uart/uart.c   **** #if defined( AT90_UART )
 331:uart/uart.c   ****     /* set baud rate */
 332:uart/uart.c   ****     UBRR = (unsigned char)baudrate; 
 333:uart/uart.c   **** 
 334:uart/uart.c   ****     /* enable UART receiver and transmmitter and receive complete interrupt */
 335:uart/uart.c   ****     UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);
 336:uart/uart.c   **** 
 337:uart/uart.c   **** #elif defined (ATMEGA_USART)
 338:uart/uart.c   ****     /* Set baud rate */
 339:uart/uart.c   ****     if ( baudrate & 0x8000 )
 340:uart/uart.c   ****     {
 341:uart/uart.c   ****     	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 342:uart/uart.c   ****     	 baudrate &= ~0x8000;
 343:uart/uart.c   ****     }
 344:uart/uart.c   ****     UBRRH = (unsigned char)(baudrate>>8);
 345:uart/uart.c   ****     UBRRL = (unsigned char) baudrate;
 346:uart/uart.c   ****    
 347:uart/uart.c   ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 348:uart/uart.c   ****     UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 349:uart/uart.c   ****     
 350:uart/uart.c   ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 351:uart/uart.c   ****     #ifdef URSEL
 352:uart/uart.c   ****     UCSRC = (1<<URSEL)|(3<<UCSZ0);
 353:uart/uart.c   ****     #else
 354:uart/uart.c   ****     UCSRC = (3<<UCSZ0);
 355:uart/uart.c   ****     #endif 
 356:uart/uart.c   ****     
 357:uart/uart.c   **** #elif defined (ATMEGA_USART0 )
 358:uart/uart.c   ****     /* Set baud rate */
 359:uart/uart.c   ****     if ( baudrate & 0x8000 ) 
 203               		.loc 1 359 0
 204 00ba 97FF      		sbrs r25,7
 205 00bc 00C0      		rjmp .L9
 360:uart/uart.c   ****     {
 361:uart/uart.c   ****    		UART0_STATUS = (1<<U2X0);  //Enable 2x speed 
 206               		.loc 1 361 0
 207 00be 22E0      		ldi r18,lo8(2)
 208 00c0 2093 C000 		sts 192,r18
 362:uart/uart.c   ****    		baudrate &= ~0x8000;
 209               		.loc 1 362 0
 210 00c4 9F77      		andi r25,127
 211               	.LVL15:
 212               	.L9:
 363:uart/uart.c   ****    	}
 364:uart/uart.c   ****     UBRR0H = (unsigned char)(baudrate>>8);
 213               		.loc 1 364 0
 214 00c6 9093 C500 		sts 197,r25
 365:uart/uart.c   ****     UBRR0L = (unsigned char) baudrate;
 215               		.loc 1 365 0
 216 00ca 8093 C400 		sts 196,r24
 366:uart/uart.c   **** 
 367:uart/uart.c   ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 368:uart/uart.c   ****     UART0_CONTROL = _BV(RXCIE0)|(1<<RXEN0)|(1<<TXEN0);
 217               		.loc 1 368 0
 218 00ce 88E9      		ldi r24,lo8(-104)
 219               	.LVL16:
 220 00d0 8093 C100 		sts 193,r24
 369:uart/uart.c   ****     
 370:uart/uart.c   ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 371:uart/uart.c   ****     #ifdef URSEL0
 372:uart/uart.c   ****     UCSR0C = (1<<URSEL0)|(3<<UCSZ00);
 373:uart/uart.c   ****     #else
 374:uart/uart.c   ****     UCSR0C = (3<<UCSZ00);
 221               		.loc 1 374 0
 222 00d4 86E0      		ldi r24,lo8(6)
 223 00d6 8093 C200 		sts 194,r24
 224 00da 0895      		ret
 225               		.cfi_endproc
 226               	.LFE3:
 228               	.global	uart_getc
 230               	uart_getc:
 231               	.LFB4:
 375:uart/uart.c   ****     #endif 
 376:uart/uart.c   **** 
 377:uart/uart.c   **** #elif defined ( ATMEGA_UART )
 378:uart/uart.c   ****     /* set baud rate */
 379:uart/uart.c   ****     if ( baudrate & 0x8000 ) 
 380:uart/uart.c   ****     {
 381:uart/uart.c   ****     	UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 382:uart/uart.c   ****     	baudrate &= ~0x8000;
 383:uart/uart.c   ****     }
 384:uart/uart.c   ****     UBRRHI = (unsigned char)(baudrate>>8);
 385:uart/uart.c   ****     UBRR   = (unsigned char) baudrate;
 386:uart/uart.c   **** 
 387:uart/uart.c   ****     /* Enable UART receiver and transmitter and receive complete interrupt */
 388:uart/uart.c   ****     UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 389:uart/uart.c   **** 
 390:uart/uart.c   **** #endif
 391:uart/uart.c   **** 
 392:uart/uart.c   **** }/* uart_init */
 393:uart/uart.c   **** 
 394:uart/uart.c   **** 
 395:uart/uart.c   **** /*************************************************************************
 396:uart/uart.c   **** Function: uart_getc()
 397:uart/uart.c   **** Purpose:  return byte from ringbuffer  
 398:uart/uart.c   **** Returns:  lower byte:  received byte from ringbuffer
 399:uart/uart.c   ****           higher byte: last receive error
 400:uart/uart.c   **** **************************************************************************/
 401:uart/uart.c   **** unsigned int uart_getc(void)
 402:uart/uart.c   **** {    
 232               		.loc 1 402 0
 233               		.cfi_startproc
 234               	/* prologue: function */
 235               	/* frame size = 0 */
 236               	/* stack size = 0 */
 237               	.L__stack_usage = 0
 403:uart/uart.c   ****     unsigned char tmptail;
 404:uart/uart.c   ****     unsigned char data;
 405:uart/uart.c   **** 
 406:uart/uart.c   **** 
 407:uart/uart.c   ****     if ( UART_RxHead == UART_RxTail ) {
 238               		.loc 1 407 0
 239 00dc 9091 0000 		lds r25,UART_RxHead
 240 00e0 8091 0000 		lds r24,UART_RxTail
 241 00e4 9817      		cp r25,r24
 242 00e6 01F0      		breq .L12
 408:uart/uart.c   ****         return UART_NO_DATA;   /* no data available */
 409:uart/uart.c   ****     }
 410:uart/uart.c   ****     
 411:uart/uart.c   ****     /* calculate /store buffer index */
 412:uart/uart.c   ****     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 243               		.loc 1 412 0
 244 00e8 E091 0000 		lds r30,UART_RxTail
 245 00ec EF5F      		subi r30,lo8(-(1))
 246 00ee EF71      		andi r30,lo8(31)
 247               	.LVL17:
 413:uart/uart.c   ****     UART_RxTail = tmptail; 
 248               		.loc 1 413 0
 249 00f0 E093 0000 		sts UART_RxTail,r30
 414:uart/uart.c   ****     
 415:uart/uart.c   ****     /* get data from receive buffer */
 416:uart/uart.c   ****     data = UART_RxBuf[tmptail];
 250               		.loc 1 416 0
 251 00f4 F0E0      		ldi r31,0
 252 00f6 E050      		subi r30,lo8(-(UART_RxBuf))
 253 00f8 F040      		sbci r31,hi8(-(UART_RxBuf))
 254               	.LVL18:
 255 00fa 2081      		ld r18,Z
 256               	.LVL19:
 417:uart/uart.c   ****     
 418:uart/uart.c   ****     return (UART_LastRxError << 8) + data;
 257               		.loc 1 418 0
 258 00fc 8091 0000 		lds r24,UART_LastRxError
 259 0100 90E0      		ldi r25,0
 260 0102 982F      		mov r25,r24
 261 0104 8827      		clr r24
 262 0106 820F      		add r24,r18
 263 0108 911D      		adc r25,__zero_reg__
 264 010a 0895      		ret
 265               	.LVL20:
 266               	.L12:
 408:uart/uart.c   ****     }
 267               		.loc 1 408 0
 268 010c 80E0      		ldi r24,0
 269 010e 91E0      		ldi r25,lo8(1)
 419:uart/uart.c   **** 
 420:uart/uart.c   **** }/* uart_getc */
 270               		.loc 1 420 0
 271 0110 0895      		ret
 272               		.cfi_endproc
 273               	.LFE4:
 275               	.global	uart_putc
 277               	uart_putc:
 278               	.LFB5:
 421:uart/uart.c   **** 
 422:uart/uart.c   **** 
 423:uart/uart.c   **** /*************************************************************************
 424:uart/uart.c   **** Function: uart_putc()
 425:uart/uart.c   **** Purpose:  write byte to ringbuffer for transmitting via UART
 426:uart/uart.c   **** Input:    byte to be transmitted
 427:uart/uart.c   **** Returns:  none          
 428:uart/uart.c   **** **************************************************************************/
 429:uart/uart.c   **** void uart_putc(unsigned char data)
 430:uart/uart.c   **** {
 279               		.loc 1 430 0
 280               		.cfi_startproc
 281               	.LVL21:
 282               	/* prologue: function */
 283               	/* frame size = 0 */
 284               	/* stack size = 0 */
 285               	.L__stack_usage = 0
 431:uart/uart.c   ****     unsigned char tmphead;
 432:uart/uart.c   **** 
 433:uart/uart.c   ****     
 434:uart/uart.c   ****     tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 286               		.loc 1 434 0
 287 0112 9091 0000 		lds r25,UART_TxHead
 288 0116 9F5F      		subi r25,lo8(-(1))
 289 0118 9F71      		andi r25,lo8(31)
 290               	.LVL22:
 291               	.L14:
 435:uart/uart.c   ****     
 436:uart/uart.c   ****     while ( tmphead == UART_TxTail ){
 292               		.loc 1 436 0 discriminator 1
 293 011a 2091 0000 		lds r18,UART_TxTail
 294 011e 9217      		cp r25,r18
 295 0120 01F0      		breq .L14
 437:uart/uart.c   ****         ;/* wait for free space in buffer */
 438:uart/uart.c   ****     }
 439:uart/uart.c   ****     
 440:uart/uart.c   ****     UART_TxBuf[tmphead] = data;
 296               		.loc 1 440 0
 297 0122 E92F      		mov r30,r25
 298 0124 F0E0      		ldi r31,0
 299 0126 E050      		subi r30,lo8(-(UART_TxBuf))
 300 0128 F040      		sbci r31,hi8(-(UART_TxBuf))
 301 012a 8083      		st Z,r24
 441:uart/uart.c   ****     UART_TxHead = tmphead;
 302               		.loc 1 441 0
 303 012c 9093 0000 		sts UART_TxHead,r25
 442:uart/uart.c   **** 
 443:uart/uart.c   ****     /* enable UDRE interrupt */
 444:uart/uart.c   ****     UART0_CONTROL    |= _BV(UART0_UDRIE);
 304               		.loc 1 444 0
 305 0130 8091 C100 		lds r24,193
 306               	.LVL23:
 307 0134 8062      		ori r24,lo8(32)
 308 0136 8093 C100 		sts 193,r24
 309 013a 0895      		ret
 310               		.cfi_endproc
 311               	.LFE5:
 313               	.global	uart_puts
 315               	uart_puts:
 316               	.LFB6:
 445:uart/uart.c   **** 
 446:uart/uart.c   **** }/* uart_putc */
 447:uart/uart.c   **** 
 448:uart/uart.c   **** 
 449:uart/uart.c   **** /*************************************************************************
 450:uart/uart.c   **** Function: uart_puts()
 451:uart/uart.c   **** Purpose:  transmit string to UART
 452:uart/uart.c   **** Input:    string to be transmitted
 453:uart/uart.c   **** Returns:  none          
 454:uart/uart.c   **** **************************************************************************/
 455:uart/uart.c   **** void uart_puts(const char *s )
 456:uart/uart.c   **** {
 317               		.loc 1 456 0
 318               		.cfi_startproc
 319               	.LVL24:
 320 013c CF93      		push r28
 321               	.LCFI13:
 322               		.cfi_def_cfa_offset 3
 323               		.cfi_offset 28, -2
 324 013e DF93      		push r29
 325               	.LCFI14:
 326               		.cfi_def_cfa_offset 4
 327               		.cfi_offset 29, -3
 328               	/* prologue: function */
 329               	/* frame size = 0 */
 330               	/* stack size = 2 */
 331               	.L__stack_usage = 2
 332 0140 EC01      		movw r28,r24
 333               	.LVL25:
 334               	.L17:
 457:uart/uart.c   ****     while (*s) 
 335               		.loc 1 457 0
 336 0142 8991      		ld r24,Y+
 337               	.LVL26:
 338 0144 8823      		tst r24
 339 0146 01F0      		breq .L19
 340               	.LVL27:
 458:uart/uart.c   ****       uart_putc(*s++);
 341               		.loc 1 458 0
 342 0148 0E94 0000 		call uart_putc
 343               	.LVL28:
 344 014c 00C0      		rjmp .L17
 345               	.LVL29:
 346               	.L19:
 347               	/* epilogue start */
 459:uart/uart.c   **** 
 460:uart/uart.c   **** }/* uart_puts */
 348               		.loc 1 460 0
 349 014e DF91      		pop r29
 350 0150 CF91      		pop r28
 351               	.LVL30:
 352 0152 0895      		ret
 353               		.cfi_endproc
 354               	.LFE6:
 356               	.global	uart_puts_p
 358               	uart_puts_p:
 359               	.LFB7:
 461:uart/uart.c   **** 
 462:uart/uart.c   **** 
 463:uart/uart.c   **** /*************************************************************************
 464:uart/uart.c   **** Function: uart_puts_p()
 465:uart/uart.c   **** Purpose:  transmit string from program memory to UART
 466:uart/uart.c   **** Input:    program memory string to be transmitted
 467:uart/uart.c   **** Returns:  none
 468:uart/uart.c   **** **************************************************************************/
 469:uart/uart.c   **** void uart_puts_p(const char *progmem_s )
 470:uart/uart.c   **** {
 360               		.loc 1 470 0
 361               		.cfi_startproc
 362               	.LVL31:
 363 0154 CF93      		push r28
 364               	.LCFI15:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 28, -2
 367 0156 DF93      		push r29
 368               	.LCFI16:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 29, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 375 0158 FC01      		movw r30,r24
 376               	.LVL32:
 377               	.L21:
 378               	.LBB2:
 471:uart/uart.c   ****     register char c;
 472:uart/uart.c   ****     
 473:uart/uart.c   ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 379               		.loc 1 473 0
 380               	/* #APP */
 381               	 ;  473 "uart/uart.c" 1
 382 015a 8491      		lpm r24, Z
 383               		
 384               	 ;  0 "" 2
 385               	.LVL33:
 386               	/* #NOAPP */
 387 015c EF01      		movw r28,r30
 388 015e 2196      		adiw r28,1
 389               	.LVL34:
 390               	.LBE2:
 391 0160 8823      		tst r24
 392 0162 01F0      		breq .L23
 474:uart/uart.c   ****       uart_putc(c);
 393               		.loc 1 474 0
 394 0164 0E94 0000 		call uart_putc
 395               	.LVL35:
 396 0168 FE01      		movw r30,r28
 397 016a 00C0      		rjmp .L21
 398               	.LVL36:
 399               	.L23:
 400               	/* epilogue start */
 475:uart/uart.c   **** 
 476:uart/uart.c   **** }/* uart_puts_p */
 401               		.loc 1 476 0
 402 016c DF91      		pop r29
 403 016e CF91      		pop r28
 404               	.LVL37:
 405 0170 0895      		ret
 406               		.cfi_endproc
 407               	.LFE7:
 409               		.local	UART_LastRxError
 410               		.comm	UART_LastRxError,1,1
 411               		.local	UART_RxTail
 412               		.comm	UART_RxTail,1,1
 413               		.local	UART_RxHead
 414               		.comm	UART_RxHead,1,1
 415               		.local	UART_TxTail
 416               		.comm	UART_TxTail,1,1
 417               		.local	UART_TxHead
 418               		.comm	UART_TxHead,1,1
 419               		.local	UART_RxBuf
 420               		.comm	UART_RxBuf,32,1
 421               		.local	UART_TxBuf
 422               		.comm	UART_TxBuf,32,1
 423               	.Letext0:
 424               		.file 2 "c:\\winavr-20100110\\avr\\include\\stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 uart.c
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:2      *ABS*:0000003e __SP_H__
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:3      *ABS*:0000003d __SP_L__
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:4      *ABS*:0000003f __SREG__
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:6      *ABS*:00000001 __zero_reg__
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:12     .text:00000000 __vector_18
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:412    .bss:00000002 UART_RxHead
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:410    .bss:00000001 UART_RxTail
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:418    .bss:00000005 UART_RxBuf
                             .bss:00000000 UART_LastRxError
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:108    .text:00000056 __vector_19
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:416    .bss:00000004 UART_TxHead
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:414    .bss:00000003 UART_TxTail
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:420    .bss:00000025 UART_TxBuf
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:186    .text:000000aa uart_init
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:230    .text:000000dc uart_getc
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:277    .text:00000112 uart_putc
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:315    .text:0000013c uart_puts
C:\Users\MUKHTA~1\AppData\Local\Temp\ccuJV6sq.s:358    .text:00000154 uart_puts_p

UNDEFINED SYMBOLS
__do_clear_bss
